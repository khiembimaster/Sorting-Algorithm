1.Idea
//-----------------------
Radix Sort is a distribution-sorting algorithm. Thus, it does not compare the items of an array.
The objective is to create groupings of data elements and then combine them to sort a collection of data.
//-----------------------
Radix Sort reorders components in what way? 
    Iteration 1: Creating groupings based on the right-most digit, which is the least significant. 
                 Bringing these groups together. 
    Iteration 2: Creating groupings based on the next-to-last digits 
                 Bringing these groups together. 
    So on....
    
    *For items with more than one significant digit,
this bucketing procedure is repeated for each digit, 
while maintaining the previous step's ordering, 
until all digits have been processed.

2.Step-by-step description
#Preparation:
Firstly, Radix Sort finds the number of digits of the maximum number. 
This value is stored in the variable "digits", which will, then be used as a stop condition.
Next, let's create a two-dimension array "tempArr" of the size 10 by "n". 
Each "temp[i]" is a queue (first-in-first-out), which is used to distribute elements by digit (0–9).
#Sorting
This process will repeat for "digits" of time:
    Set the temporary array to its default value (a[i][j] == 0)
    Enque all elements into their correct groups (0-9).
    Sequentially combine ten groups from left to right (i = 0 to i = 9). 
    Since the process started from the least significant radix, 
    The result array of the combination is an array 
    whose elements have the same number of digits as that iteration are sorted,
    while those smaller ones won't be changed.

#After this process, we will have an sorted array.  

3.Complexity evaluations
a.Time Complexity
    T(n) = find maximum value --> run for n time ==> O(n) 
        +  calculate digits's value --> depend on max_val ==> O(digits)
        +  create tempArr --> 10 groups ==> O(10) = O(1) = constant
        +  form groups of numbers and combine groups (*)
    (*) = digits * (reset tempCount + form groups + combine groups)
        *reset tempCount = 10 times.
        *form groups = n.
        *combine groups = 10 * number of elements in that class = n.  
==> (*) = O(digits * (2n + 10)) = O(digits * n)
    digits = log base 10 of max_val.
    let max_val <= n^constant.
    then digits <= constant * (log base 10 of n).
    (*) = O((log base 10 of n) * n).
    As log base 10 of a number is close to a constant --> (*) = O(n).

==> Thus, T(n) = O(n) + O(d) + O(1) + (*) = O(n)

b.Space Complexity
    size of "tempArr" = 10*n (int).
    size of "tempCount" = 10 (int).
    ==> Extra Space needed is an upper bound of n.
